在我以往的理解中，容器和镜像的关系就是：
- 容器是运行的，活着的镜像，就像 instance
- 镜像是静止的，就像 class
- 当把镜像 run 起来变成容器，就像是吧 class new 了一个 instance 出来

不过，最近对docker 的底层研究了后，又有了一些新的认识。

一个“容器”，实际上是一个由 `Linux Namespace`、`Linux Cgroups` 和 `rootfs` 三种技术构建出来的进程的隔离环境。

从这个结构中我们不难看出，一个正在运行的 `Linux` 容器，其实可以被“一分为二”地看待：
- 一组联合挂载在 `/var/lib/docker/aufs/mnt` 上的 `rootfs`，这一部分我们称为“容器镜像”（`Container Image`），是容器的静态视图；
- 一个由 `Namespace + Cgroups` 构成的隔离环境，这一部分我们称为“容器运行时”（`Container Runtime`），是容器的动态视图。


而在实际使用中，我们并不关心容器运行时的差异。因为，在整个 `devops` 的流程中，**真正承载着容器信息进行传递的，是容器镜像，而不是容器运行时。** 

而容器编排这个技术开始盛行的原因是：作为一家云服务商或者基础设施提供商，我们只要能够将用户提交的镜像以容器的方式运行起来，就能成为这个非常热闹的容器生态图上的一个承载点，从而将整个容器技术栈上的价值，沉淀在我的这个节点上。

更重要的是，只要从我这个承载点向 Docker 镜像制作者和使用者方向回溯，整条路径上的各个服务节点，比如 CI/CD、监控、安全、网络、存储等等，都有我可以发挥和盈利的余地。这个逻辑，正是所有云计算提供商如此热衷于容器技术的重要原因：通过容器镜像，它们可以和潜在用户（即，开发者）直接关联起来。

从一个开发者和单一的容器镜像，到无数开发者和庞大的容器集群，容器技术实现了从“容器”到“容器云”的飞跃，标志着它真正得到了市场和生态的认可。

这样，容器就从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角；而能够定义容器组织和管理规范的“容器编排”技术，则当仁不让地坐上了容器技术领域的“头把交椅”。